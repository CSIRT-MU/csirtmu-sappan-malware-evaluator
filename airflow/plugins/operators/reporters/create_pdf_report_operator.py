from airflow.models import BaseOperator
from airflow.utils.decorators import apply_defaults
from airflow.hooks.S3_hook import S3Hook
from tempfile import NamedTemporaryFile
from xhtml2pdf import pisa
import json


class CreatePDFReportOperator(BaseOperator):
    """
    This operator takes report from Observable-Evaluator microservice and report from netflow data, then transforms it into PDF report and uploads it to the S3

    :data: dict = PDF report
    :netflow_data = Report from nfdump data
    :bucket: str = S3 bucket name
    :s3_conn_id: str = connection ID of S3 Connection
    :print_raw: bool = whether we want to put raw tool reports from IntelOwl into the PDF or not

    """
    template_fields = ('data', 'netflow_data', 'bucket',
                       's3_conn_id', 'print_raw')

    @apply_defaults
    def __init__(self,
                 data,
                 netflow_data,
                 bucket,
                 print_raw=False,
                 s3_conn_id="s3_conn_id",
                 *args,
                 **kwargs):

        super().__init__(*args, **kwargs)
        self.data = data
        self.netflow_data = netflow_data
        self.bucket = bucket
        self.print_raw = print_raw
        self.s3_conn_id = s3_conn_id

    def translate_tool_name(self, detected):
        tools = {
            "VirusTotal_v3_Get_File_And_Scan": "VirusTotal",
            "HybridAnalysis_Get_File": "HybridAnalysis",
            "OTX_Check_Hash": "OTX Alien Vault",
            "VirusTotal_v3_Get_Observable": "VirusTotal",
            "OTXQuery": "OTX Alien Vault",
            "GoogleSafebrowsing": "Google Safebrowsing",
            "CloudFlare_Malicious_Detector": "CloudFlare",
            "HybridAnalysis_Get_Observable": "HybridAnalysis"
        }

        return tools.get(detected, detected)

    def return_styles_section(self):
        return f"""<style>
        h1 {{
            padding: 0;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            font-size: 16px;
        }}
        th {{
            text-align: center;
            padding-top: 2px;
            font-size: 12px;
            font-weight: bold;

            width: 10%;
        }}
        td {{
            text-align: center;
            padding-top: 2px;
            width: 100%;
            font-size: 12px;
        }}

        table, th, td {{
            border: 1px solid black;
            border-collapse: collapse;
        }}

        table {{
            width: 100%;

        }}
        @media print {{
            .new-page {{
                page-break-after: always;
            }}
        }}
        </style>
        """

    def return_aliases(self, data, first_page):
        aliases = data['aliases']
        aliases_n = len(aliases)
        html = ""
        if (aliases_n > 1):
            lower_bound = 0

            while aliases_n > 0:
                if first_page:
                    max_aliases = 35
                else:
                    max_aliases = 45

                current_size = aliases_n if aliases_n < max_aliases else max_aliases
                upper_bound = lower_bound + current_size
                aliases_rows = ""
                index = lower_bound
                while (index < upper_bound):
                    if (index > lower_bound):
                        aliases_rows += "<tr>"

                    alias = aliases[index]
                    size_check = len(alias) // 90
                    if (size_check > 0):
                        for i in range(0, size_check):
                            alias = f"{alias[0:(i+1)*90]}\n{alias[(i+1)*90:len(alias)]}"
                            upper_bound -= 1
                            current_size -= 1

                    aliases_rows += f"""
                            <td class="block">{alias}</td>
                        </tr>
                        """
                    index += 1
                html += f"""
                    <tr>
                        <th colspan="2" rowspan="{current_size}">Aliases</th>
                        {aliases_rows}
                    """
                first_page = 0
                lower_bound = current_size + lower_bound
                aliases_n -= current_size
        return html

    def return_basic_information_section(self, data):
        html = f"""
        <section class="new-page">
        <h3> Basic information </h3>
        <table id = "information">
            <tr>
                <th colspan = 2> Name </th>
                <td class="block"> {data['filename']} </td>
            </tr>
            <tr>
                <th rowspan = "3"> Hash </th>
                <th> MD5 </th>
                <td class="block"> {data['file_info']['md5']} </td>
            </tr>
                <th> SHA1 </th>
                <td class="block"> {data['file_info']['sha1']} </td>
            <tr>
                <th> SHA256 </th>
                <td class="block"> {data['file_info']['sha256']} </td>
            </tr>
        """
        html += self.return_aliases(data, first_page=1)
        html += f"""
        <tr>
          <th colspan = "2"> Tagged as malicious</th> <td> {", ".join([self.translate_tool_name(evaluated) for evaluated in data['tagged_as_malicious']])} </td>
        </tr>
        <tr>
          <th colspan = "2"> Tagged as harmless</th> <td> {", ".join([self.translate_tool_name(evaluated) for evaluated in data['tagged_as_harmless']])} </td>
        </tr>
        </table>
        </section>
        <div>
            <pdf:nextpage />
        </div>
        """
        return html

    def return_observables_section(self, data):
        html = f"""
        <section class="new-page">
        <h3> Found observables </h3>
        <table id = "observables">
            <thead>
                <tr>
                    <th> Observable </th>
                    <th> Type </th>
                    <th> Malicious </th>
                    <th> Detected by </th>
                    <th> Tagged malicious </th>
                    <th> Tagged harmless </th>
                </tr>
            </thead>
            <tbody>
        """
        for observable in data:
            observable_name = observable['observable']
            counter = len(observable_name) // 21
            if (counter > 0):
                counter += 1 if (len(observable_name) % 21 > 0) else 0
                for i in range(1, counter):
                    observable_name = f"{observable_name[0:i*21]}\n{observable_name[i*21:len(observable_name)]}"
            html += f"""
                <tr>
                    <td class="block"> {observable_name} </td>
                    <td class="block"> {observable['observable_type']} </td>
                    <td class="block"> {observable['malicious_info']} </td>
                    <td class="block"> {", ".join([self.translate_tool_name(detected) for detected in observable['detected']])} </td>
                    <td class="block"> {", ".join([self.translate_tool_name(evaluated) for evaluated in observable['tagged_as_malicious']])} </td>
                    <td class="block"> {", ".join([self.translate_tool_name(evaluated) for evaluated in observable['tagged_as_harmless']])} </td>
                </tr>
            """
        html += f"""
                </tbody>
            </table>
        </section>
        <div>
            <pdf:nextpage /> 
        </div> 
        """
        return html

    def return_tool_reports_section(self, data):
        html = f"""
                <section>
                <h3>Raw reports</h3>
        """
        for toolname, tool in data['reports'].items():
            html += f"""<h4>{self.translate_tool_name(toolname)}</h4>
            <pre>
            <code>
            {json.dumps(tool['raw'],indent=2,sort_keys=True)}
            </code>
            </pre>
            """
        html += "</section>"
        return html

    def return_netflow_stats_table(self, data):
        html = f"""<table id = "observables">
                <thead>
                    <tr>
                        <th> Statistic </th>
                        <th> Value </th>
                    </tr>
                </thead>
                <tbody>
            """
        for stat, val in data.items():
            html += f"""
                <tr>
                    <td class="block"> {stat} </td>
                    <td class="block"> {val} </td>
                </tr>
            """
        html += f"""
                </tbody>
            </table>"""
        return html

    def return_netflow_ip_table(self, ips):
        html = f"""<table id = "observables">
                <thead>
                    <tr>
                        <th> Source IP </th>
                        <th> Malicious Observable </th>
                        <th> First communication time </th>
                    </tr>
                </thead>
                <tbody>
            """
        for row in ips:
            source_ip = row[0]
            observable = row[1]
            start = row[2]
            html += f"""
                <tr>
                    <td class="block"> {source_ip} </td>
                    <td class="block"> {observable} </td>
                    <td class="block"> {start} </td>
                </tr>
            """
        html += f"""
                </tbody>
            </table>"""
        return html

    def return_netflow_section(self, data):
        html = f"""
        <section class="new-page">
        <h3> Netflow report </h3>"""

        if not data.get('ips'):
            html += f"<p> {data['info_msg']} </p>"
        else:
            html += self.return_netflow_ip_table(data['ips'])
            html += '<hr>'  # to separate the tables
            html += self.return_netflow_stats_table(data['stats'])
        html += f"""    
        </section>
        <div>
            <pdf:nextpage /> 
        </div> 
        """
        return html

    def apply_data_to_template(self, data, netflow_data):
        html = self.return_styles_section()
        html += f"""<h1>Report for {data['filename']}</h1>
        <section>
        """
        if data['malicious']:
            html += f"""
                <h3>Result</h3>
                <p>
                    Malware-pipeline evaluated file {data['filename']} as malicious.
                </p>
                """
        else:
            html += f"""
                <h3>Result</h3>
                <p>
                    Malware-pipeline evaluated file {data['filename']} as harmless.
                </p>
        """
        html += "</section>"
        html += self.return_basic_information_section(data)
        if not data['malicious']:
            return html

        html += self.return_observables_section(data['observables'].values())

        html += self.return_netflow_section(netflow_data)

        if self.print_raw:
            html += self.return_tool_reports_section(data)

        return html

    def execute(self, context):
        html = self.apply_data_to_template(self.data, self.netflow_data)
        s3_hook = S3Hook(self.s3_conn_id)
        s3_client = s3_hook.get_conn()
        key = f"{self.data['filename']}-report.pdf"
        with NamedTemporaryFile("w+b") as f:
            pisa_status = pisa.CreatePDF(
                html,
                dest=f)
            f.seek(0, 0)
            s3_client.upload_fileobj(f.file, self.bucket, key)

        return key
