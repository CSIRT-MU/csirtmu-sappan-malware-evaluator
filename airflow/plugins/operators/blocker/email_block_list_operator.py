from hooks.blocker_api.email_blocker_hook import EmailBlockerApiHook
from airflow.models import BaseOperator
from airflow.utils.decorators import apply_defaults
from typing import List


class BlockEmailListOperator(BaseOperator):
    """
    This operator takes information about domains and tries to blacklist them

    :email_list: list = list of parameters for blocking [{"ip" : str, "reason" : str, "length" : int, "who" : str}]
    :conn_id: str = connection ID of Mock API Email blocker Connection
    """
    template_fields = ('email_list', 'conn_id')

    @apply_defaults
    def __init__(
            self,
            *,
            email_list,
            conn_id: str = 'blocker_conn_id',
            **kwargs) -> None:
        super().__init__(**kwargs)
        self.email_list = email_list
        self.conn_id = conn_id

    def is_email_blocked(self, email, hook):
        data = hook.get_email_blacklist()

        for email_record in data.results:
            if email == email_record.email:
                return True

        return False

    def execute(self, context):
        print(self.email_list)
        hook = EmailBlockerApiHook(self.conn_id)
        emails_output = []
        for email_record in self.email_list:
            # blacklisted is used to distinguish mails that are already blocked
            # and mails that were blocked by this operator
            blacklisted = self.is_email_blocked(email_record['email'], hook)
            blocked = False
            if not blacklisted:
                hook.ban_email(email_record['email'], email_record['reason'],
                               email_record['length'], email_record['who'])
                blocked = True

            emails_output.append({
                'email': email_record['email'],
                'blacklisted': blacklisted,
                'blocked': blocked
            })

        return emails_output
