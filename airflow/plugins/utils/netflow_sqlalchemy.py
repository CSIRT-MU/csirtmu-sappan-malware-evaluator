from typing import List, Union, Optional
from sqlalchemy import create_engine, MetaData, Table, Column, func
from sqlalchemy.orm import sessionmaker
import operator

# mapping dict of arithmetic functions
ARITHMETIC_FUNCS = { 'sum': func.sum, 
                    'count': func.count, 
                    'min': func.min, 
                    'max': func.max,
                    'avg': func.avg }

# mapping dict of arithemtic operators
OPERATORS = { '=': operator.eq,
              '!=': operator.ne, 
              '>': operator.gt,
              '>=': operator.ge,
              '<': operator.lt,
              '<=': operator.le}

class NetflowQuery:
    """Represents basic unit of logic for querying, holds information about internal query structure
    """
    
    def __init__(self, table: str, cols: Union[List, str] = '*', filters: Optional[List] = None, groupby: Optional[List[str]] = None, limit: Optional[int] = None, order_by: Optional[Union[str, tuple]] = None, ascending: bool = True):
        self.cols = cols
        self.table = table
        self.filters = filters
        self.groupby = groupby
        self.limit = limit
        self.order_by = order_by
        self.ascending = ascending
    
    def transform_col(self, col: Union[str, tuple]):
        if type(col) == str:
            return self.db_table.columns[col]
        else:
            return ARITHMETIC_FUNCS[col[1]](self.db_table.columns[col[0]])
    
    def transform_cols(self, cols: List):
        return list(map(self.transform_col, cols))
            
    def execute(self, metadata, session):
        self.db_table = Table(self.table, metadata, autoload=True)
        db_cols = self.transform_cols(self.cols) if self.cols != '*' else self.db_table.columns
        query = session.query(*db_cols)
        query = self.apply_filters(query)
        query = self.apply_grouping(query)
        query = self.apply_sorting(query)
        query = self.apply_limit(query)
        return query.all()
    
    def apply_filters(self, query):
        if self.filters == None:
            return query
        for filter_ in self.filters:
            filter_type = filter_[0]
            directive = filter_[1]
            if filter_type == 'rng':
                mini = directive[1][0]
                maxi = directive[1][1]
                query = query.filter(Column(directive[0]).between(mini, maxi))
            elif filter_type == 'in':
                query = query.filter(Column(directive[0]).in_(directive[1]))
            elif filter_type == 'notin':
                query = query.filter(Column(directive[0]).not_in(directive[1]))
            elif filter_type == 'like':
                query = query.filter(Column(directive[0]).like(directive[1]))
            elif filter_type in OPERATORS.keys():
                query = self.apply_compare_filter(filter_type, directive[0], directive[1], query)
            else:
                raise ValueError(f'Unsupported filter type: {filter_type}')
        return query
    
    def apply_compare_filter(self, oper: str, col: str, val, query):
        return query.filter(OPERATORS[oper](Column(col), val))
    
    def apply_grouping(self, query):
        if not self.groupby:
            return query
        group_cols = self.transform_cols(self.groupby)
        return query.group_by(*group_cols)
    
    def apply_limit(self, query):
        if self.limit:
            return query.limit(self.limit)
        return query
    
    def apply_sorting(self, query):
        if not self.order_by:
            return query
        col = self.transform_col(self.order_by)
        col = col if self.ascending else col.desc()
        return query.order_by(col)
    
class DatabaseSession:
    """Represents database session to allow NetflowQuery objects to be executed as queries to the database specified in the __init__
    """
    
    def __init__(self, engine = None, username: str = None, password: str = None, database = None, host='localhost', port=5432):
        if engine:
            self.engine = engine
        else:
            self.engine = create_engine(f'postgresql://{username}:{password}@{host}:{port}/{database}')
        self.metadata = MetaData(bind=self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
            
    def run_query(self, query: NetflowQuery):
        # handle exceptions
        res = query.execute(self.metadata, self.session)
        return res
        # TODO handle exceptions
        """
        try:
            res = query.execute(self.metadata, self.session)
            return res
        except Exception as e:
            #handle
            print(e)
            pass
        """