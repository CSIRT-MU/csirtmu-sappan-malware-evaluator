from minio import Minio
from minio.helpers import ObjectWriteResult
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship, Query

from csirtmu.malware_gateway_backend.db import mapper_registry, session, engine
from csirtmu.malware_gateway_backend.utils import MinioClient, parse_minio_webhook_request
from urllib.parse import unquote

Base = mapper_registry.generate_base()
minio_client = MinioClient().get_client()


class CachedBucket(Base):
    __tablename__ = 'cached_bucket'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    local_alias = Column(String)

    @classmethod
    def create_if_exists_on_remote(cls, name: str):
        if minio_client.bucket_exists(name):
            bucket = cls(name=name)
            session.add(bucket)
            session.commit()
            return bucket
        return None


class CachedObject(Base):
    __tablename__ = 'cached_object'
    id = Column(Integer, primary_key=True)
    key = Column(String)
    etag = Column(String)
    content_type = Column(String)
    cached_bucket_id = Column(Integer, ForeignKey('cached_bucket.id'))
    cached_bucket = relationship(CachedBucket, backref='cached_objects')

    @classmethod
    def create_from_minio_response(cls, response: ObjectWriteResult):
        bucket = session.execute(Query(CachedBucket).where(CachedBucket.name == response.bucket_name)).scalar()
        if not bucket:
            bucket = CachedBucket.create_if_exists_on_remote(response.bucket_name)

        obj = cls(
            etag=response.etag,
            key=unquote(response.object_name),
            cached_bucket=bucket
        )
        session.add(obj)
        session.commit()
        return obj

    @classmethod
    def refresh_object_cache_for_bucket(cls, mc: Minio, bucket_name):
        # TODO: support recursion / subfolders
        remote_reports = mc.list_objects(bucket_name=bucket_name, recursive=False)

        bucket = session.execute(Query(CachedBucket).where(CachedBucket.name == bucket_name)).scalar()
        if not bucket:  # Cache is empty, check if bucket exists on remote
            bucket = CachedBucket.create_if_exists_on_remote(bucket_name)
            if not bucket:  # If it doesn't, fail
                return None

        cached_etags = session.execute(
            Query(CachedObject.etag).where(CachedObject.cached_bucket == bucket))\
            .scalars().all()

        cached_etags = set(cached_etags)
        for report in remote_reports:
            if report.etag and report.etag not in cached_etags:  # TODO: Recursion: Folders don't have etag
                cls.create_from_minio_response(report)


class CachedEvent(Base):
    __tablename__ = 'cached_event'
    id = Column(Integer, primary_key=True)
    event = Column(String)
    key = Column(String)
    time = Column(DateTime)
    cached_object_id = Column(Integer, ForeignKey('cached_object.id'))
    cached_object = relationship(CachedObject, backref='cached_events')

    @classmethod
    def save_incoming_webhook(cls, webhook):
        parsed_req = parse_minio_webhook_request(webhook)
        event = cls(event=parsed_req.get('event'), key=parsed_req.get('key'),
                    time=parsed_req.get('event_time'))


        session.add(event)
        session.commit()
        return event


mapper_registry.metadata.create_all(engine)
