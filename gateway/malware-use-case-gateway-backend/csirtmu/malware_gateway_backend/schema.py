import asyncio
from asyncio import Event
from typing import Any, Dict, Union, List

import strawberry
from strawberry import Schema

from csirtmu.malware_gateway_backend import models
from csirtmu.malware_gateway_backend.constants import MINIO_REPORT_BUCKET
from csirtmu.malware_gateway_backend.db import session

events: Dict[str, Dict[str, Union[Event, Any]]] = {}


@strawberry.type
class CachedBucket:
    name: str


@strawberry.type
class CachedObject:
    key: str
    etag: str
    content_type: str
    cached_bucket: CachedBucket


@strawberry.type
class Query:
    @strawberry.field
    def cached_reports(self) -> List[CachedObject]:
        return session.query(models.CachedObject).join(models.CachedBucket)\
                      .where(models.CachedBucket.name == MINIO_REPORT_BUCKET).all()

    @strawberry.field
    def cached_objects(self) -> List[CachedObject]:
        return session.query(models.CachedObject).all()

    @strawberry.field
    def cached_object(self, etag: str) -> CachedObject:
        return session.query(models.CachedObject).where(models.CachedObject.etag == etag).scalar()

    @strawberry.field
    def cached_buckets(self) -> List[CachedBucket]:
        return session.query(models.CachedBucket).all()

    @strawberry.field
    def cached_bucket(self, name: str) -> CachedBucket:
        return session.query(models.CachedBucket).where(models.CachedBucket.name == name).scalar()


@strawberry.type
class Subscription:
    @strawberry.subscription
    async def minio(self, report_name: str) -> str:
        event = events.get(report_name)

        if event is None:
            return

        await asyncio.wait_for(event['event'].wait(), None)
        yield events[report_name]['result'].etag
        event['event'].clear()


schema = Schema(query=Query, subscription=Subscription)
