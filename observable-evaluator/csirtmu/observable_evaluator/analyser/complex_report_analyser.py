from typing import List, Dict
from os import environ
from csirtmu.observable_evaluator.analyser.factories.intel_owl_report_factory import IntelOwlReportFactory
from csirtmu.observable_evaluator.analyser.factories.intel_owl_analyser_factory import IntelOwlAnalyserFactory
from csirtmu.observable_evaluator.analyser.analysis_result import Analysis, FileAnalysis, ObservableAnalysis


class ComplexReportAnalyser():

    def collect_unique_observables(self, reports: List[FileAnalysis]) -> List[Dict]:
        unique_observables = {}

        for report in reports.values():
            for observable_name, observable in report.observables.items():
                if observable_name in unique_observables:
                    unique_observables[observable_name].detected += observable.detected
                else:
                    unique_observables.update({observable_name: observable})

        return unique_observables

    def collect_unique_aliases(self, reports: List[FileAnalysis]) -> List[str]:
        unique_aliases = set()
        for report in reports.values():
            unique_aliases.update(report.aliases)
        return list(unique_aliases)

    def perform_base_analysis(self, analysis_result, **kwargs) -> Analysis:

        results = {
            "reports": {},
            "malicious": False,
            "malicious_info": "No",
            "score": 0,
            "tagged_as_malicious": [],
            "tagged_as_harmless": [],
            "errors": []
        }

        for intelowl_report in analysis_result["analysis_reports"]:
            if not intelowl_report["success"]:
                results["errors"] = intelowl_report["errors"]
                continue

            report = IntelOwlReportFactory.get_report(intelowl_report)
            analyser = IntelOwlAnalyserFactory.get_analyser(report.name)
            result = analyser.analyse(report, **kwargs)
            results["reports"][report.name] = result
            if result.malicious:
                observable_type = analysis_result["observable_classification"]
                # check if type is not empty -> set type as file
                observable_type = 'file' if observable_type == '' else observable_type
                #file_name = analysis_result.get('file_name')
                #obs_name = analysis_result.get('observable_name')
                #print(f"Report {report.name} type {observable_type} file_name {file_name} obs_name {obs_name}")
                results["tagged_as_malicious"].append(report.name)
                weight = environ.get(f"{report.name}_weight_{observable_type}")
                results["score"] += float(weight) * 100
            else:
                results["tagged_as_harmless"].append(report.name)

        malicious_threshold = int(environ.get("MALICIOUS_THRESHOLD"))
        suspicious_threshold = int(environ.get("SUSPICIOUS_THRESHOLD"))
        results["malicious"] = results["score"] >= malicious_threshold
        
        if results["score"] >= malicious_threshold:
            results["malicious_info"] = "Yes"
        elif results["score"] >= suspicious_threshold:
            results["malicious_info"] = "Suspicious"
        
        return Analysis(**results)

    def analyse_file(self, analysis_result, **kwargs) -> FileAnalysis:
        # get file info as special
        file_attributes = {
            "filename": analysis_result["file_name"],
            "observables": []
        }

        if "File_Info" in analysis_result["analyzers_to_execute"]:
            for intelowl_report in analysis_result["analysis_reports"]:
                if intelowl_report["name"] == "File_Info":
                    report = IntelOwlReportFactory.get_report(intelowl_report)
                    analysis_result["analysis_reports"].remove(intelowl_report)
                    file_attributes["file_info"] = report.report.to_dict()

        analysis = self.perform_base_analysis(analysis_result, **kwargs)

        file_attributes["observables"] = self.collect_unique_observables(
            analysis.reports)
        file_attributes["aliases"] = self.collect_unique_aliases(
            analysis.reports)

        analysis_serialized = analysis.to_dict()
        analysis_serialized.update(file_attributes)
        return FileAnalysis(
            **(analysis_serialized)
        )

    def analyse_observable(self, analysis_result, **kwargs) -> ObservableAnalysis:
        observable_attributes = {
            "observable": analysis_result["observable_name"],
            "observable_type": analysis_result["observable_classification"]
        }
        if detected := kwargs.get("detected", None):
            observable_attributes["detected"] = detected

        analysis = self.perform_base_analysis(analysis_result, **kwargs)
        analysis_serialized = analysis.to_dict()
        analysis_serialized.update(observable_attributes)
        return ObservableAnalysis(
            **analysis_serialized
        )
